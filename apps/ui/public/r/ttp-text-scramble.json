{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ttp-text-scramble",
  "type": "registry:block",
  "title": "Text Scramble",
  "description": "Scrambled text effect that reveals characters sequentially",
  "files": [
    {
      "path": "components/ui/totheprod-ui/ttp-text-scramble.tsx",
      "content": "\"use client\"\n\nimport { useEffect, useRef, useState } from \"react\"\nimport { cn } from \"@/lib/utils\"\n\ntype TextScrambleProps = {\n  text: string\n  className?: string\n  charClassName?: string\n  duration?: number\n  scrambleSpeed?: number\n  trigger?: boolean\n  onComplete?: () => void\n}\n\nconst RANDOM_CHARS =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*\"\nconst UPPERCASE_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nconst LOWERCASE_CHARS = \"abcdefghijklmnopqrstuvwxyz\"\nconst UPPERCASE_REGEX = /[A-Z]/\nconst LOWERCASE_REGEX = /[a-z]/\n\nconst getRandomChar = (originalChar: string) => {\n  // If original is uppercase letter, return uppercase random char\n  if (UPPERCASE_REGEX.test(originalChar)) {\n    return UPPERCASE_CHARS[Math.floor(Math.random() * UPPERCASE_CHARS.length)]\n  }\n  // If original is lowercase letter, return lowercase random char\n  if (LOWERCASE_REGEX.test(originalChar)) {\n    return LOWERCASE_CHARS[Math.floor(Math.random() * LOWERCASE_CHARS.length)]\n  }\n  // For numbers and special chars, use full set\n  return RANDOM_CHARS[Math.floor(Math.random() * RANDOM_CHARS.length)]\n}\n\nexport const TextScramble = ({\n  text,\n  className,\n  charClassName,\n  duration = 2000,\n  scrambleSpeed = 50,\n  trigger = true,\n  onComplete,\n}: TextScrambleProps) => {\n  const [displayText, setDisplayText] = useState(\n    text.split(\"\").map((char) => (char === \" \" ? \" \" : getRandomChar(char)))\n  )\n  const revealedIndicesRef = useRef<Set<number>>(new Set())\n\n  useEffect(() => {\n    if (!trigger) {\n      setDisplayText(text.split(\"\"))\n      revealedIndicesRef.current = new Set(text.split(\"\").map((_, i) => i))\n      return\n    }\n\n    const chars = text.split(\"\")\n    const revealDelay = duration / chars.length\n\n    // Initialize with random characters\n    setDisplayText(\n      chars.map((char) => (char === \" \" ? \" \" : getRandomChar(char)))\n    )\n    revealedIndicesRef.current = new Set()\n\n    // Scramble interval - keeps updating non-revealed characters\n    const scrambleInterval = setInterval(() => {\n      setDisplayText((prev) =>\n        prev.map((char, index) => {\n          if (revealedIndicesRef.current.has(index)) {\n            return char // Keep revealed characters\n          }\n          return chars[index] === \" \" ? \" \" : getRandomChar(chars[index])\n        })\n      )\n    }, scrambleSpeed)\n\n    // Reveal timeouts - reveal each character sequentially\n    const timeouts: NodeJS.Timeout[] = []\n\n    chars.forEach((char, index) => {\n      const timeout = setTimeout(() => {\n        revealedIndicesRef.current.add(index)\n        setDisplayText((prev) => {\n          const newText = [...prev]\n          newText[index] = char\n          return newText\n        })\n\n        // Check if all characters are revealed\n        if (index === chars.length - 1) {\n          clearInterval(scrambleInterval)\n          onComplete?.()\n        }\n      }, index * revealDelay)\n\n      timeouts.push(timeout)\n    })\n\n    return () => {\n      clearInterval(scrambleInterval)\n      // biome-ignore lint/complexity/noForEach: Cleanup pattern requires forEach\n      // biome-ignore lint/suspicious/useIterableCallbackReturn: clearTimeout has no meaningful return value\n      timeouts.forEach((timeout) => clearTimeout(timeout))\n    }\n  }, [text, duration, scrambleSpeed, trigger, onComplete])\n\n  // Group characters into words for rendering\n  const words: { chars: string[]; indices: number[] }[] = []\n  let currentWord: { chars: string[]; indices: number[] } = {\n    chars: [],\n    indices: [],\n  }\n\n  displayText.forEach((char, index) => {\n    if (char === \" \") {\n      if (currentWord.chars.length > 0) {\n        words.push(currentWord)\n        currentWord = { chars: [], indices: [] }\n      }\n      // Add space as its own word\n      words.push({ chars: [\" \"], indices: [index] })\n    } else {\n      currentWord.chars.push(char)\n      currentWord.indices.push(index)\n    }\n  })\n\n  // Don't forget the last word if there's no trailing space\n  if (currentWord.chars.length > 0) {\n    words.push(currentWord)\n  }\n\n  return (\n    <div className={cn(\"flex flex-wrap\", className)}>\n      {words.map((word, wordIndex) => (\n        <div className=\"inline-flex whitespace-nowrap\" key={wordIndex}>\n          {word.chars.map((char, charIndex) => (\n            <div\n              className={cn(\"inline-block\", charClassName)}\n              key={word.indices[charIndex]}\n              style={{\n                minWidth: char === \" \" ? \"0.25em\" : undefined,\n              }}\n            >\n              {char === \" \" ? \"\\u00A0\" : char}\n            </div>\n          ))}\n        </div>\n      ))}\n    </div>\n  )\n}\n",
      "type": "registry:component"
    }
  ],
  "meta": {
    "category": "text-animations",
    "tags": [
      "text",
      "animation",
      "scramble",
      "reveal"
    ],
    "installCommand": "npx shadcn@latest add https://ui.totheprod.com/r/ttp-text-scramble.json"
  }
}
