{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ttp-word-shuffler",
  "type": "registry:block",
  "title": "Word Shuffler",
  "description": "Dynamic text shuffle animation on component mount",
  "dependencies": ["motion", "framer-motion"],
  "files": [
    {
      "path": "components/ui/totheprod-ui/ttp-word-shuffler.tsx",
      "content": "\"use client\"\n\nimport { AnimatePresence, motion } from \"framer-motion\"\nimport { useCallback, useEffect, useRef, useState } from \"react\"\nimport { cn } from \"@/lib/utils\"\n\ntype WordShufflerProps = {\n  baseText?: string\n  words?: string[]\n  interval?: number\n  letterSpacing?: number\n  textClassName?: string\n}\n\ntype LetterState = {\n  char: string\n  index: number\n  id: string\n  isCommon: boolean\n  prevIndex?: number\n  position: number\n  prevPosition?: number\n}\n\nexport const WordShuffler = ({\n  baseText = \"ToTheProd\",\n  words = [\"Marketing\", \"SEO\", \"Analytics\", \"Content\"],\n  interval = 1000,\n  letterSpacing = 10,\n  textClassName,\n}: WordShufflerProps) => {\n  const stableWords = JSON.stringify(words)\n\n  const [currentWord, setCurrentWord] = useState(0)\n  const [letterStates, setLetterStates] = useState<LetterState[]>([])\n  const [shouldFadeOut, setShouldFadeOut] = useState(false)\n  const measureRef = useRef<HTMLSpanElement>(null)\n\n  const measureLetterWidth = useCallback(\n    (char: string): number => {\n      if (!measureRef.current) {\n        return 20\n      }\n      measureRef.current.textContent = char\n      return measureRef.current.offsetWidth + letterSpacing\n    },\n    [letterSpacing]\n  )\n\n  const calculatePositions = useCallback(\n    (text: string): number[] => {\n      const positions: number[] = []\n      let cumulativeWidth = 0\n\n      // biome-ignore lint/complexity/noForEach: Accumulating positions requires forEach pattern\n      text.split(\"\").forEach((char) => {\n        positions.push(cumulativeWidth)\n        cumulativeWidth += measureLetterWidth(char)\n      })\n\n      return positions\n    },\n    [measureLetterWidth]\n  )\n\n  useEffect(() => {\n    const currentText = stableWords[currentWord].toUpperCase()\n    const prevText =\n      stableWords[\n        (currentWord - 1 + stableWords.length) % stableWords.length\n      ].toUpperCase()\n\n    const currentPositions = calculatePositions(currentText)\n    const prevPositions = calculatePositions(prevText)\n\n    // Track occurrence count for each character\n    const getOccurrenceCount = (text: string, targetIndex: number): number => {\n      const char = text[targetIndex]\n      let count = 0\n      for (let i = 0; i <= targetIndex; i++) {\n        if (text[i] === char) {\n          // biome-ignore lint/nursery/noIncrementDecrement: Simple counter increment is clearer here\n          count++\n        }\n      }\n      return count\n    }\n\n    // Track which letters from previous word have been used\n    const prevLettersUsed = new Array(prevText.length).fill(false)\n    const newLetterStates: LetterState[] = []\n\n    // Map current word letters\n    currentText.split(\"\").forEach((char, index) => {\n      const currentOccurrence = getOccurrenceCount(currentText, index)\n\n      // First check if letter at same position\n      if (prevText[index] === char) {\n        prevLettersUsed[index] = true\n        newLetterStates.push({\n          char,\n          index,\n          id: `static-${char}-${currentOccurrence}-${index}`,\n          isCommon: true,\n          prevIndex: index,\n          position: currentPositions[index],\n          prevPosition: prevPositions[index],\n        })\n      } else {\n        // Find matching letter in previous word that hasn't been used yet\n        const prevIndex = prevText\n          .split(\"\")\n          .findIndex(\n            (prevChar, pIdx) => prevChar === char && !prevLettersUsed[pIdx]\n          )\n\n        if (prevIndex !== -1) {\n          // Letter exists in different position - slide horizontally\n          prevLettersUsed[prevIndex] = true\n          newLetterStates.push({\n            char,\n            index,\n            id: `slide-${char}-occ${currentOccurrence}-${prevIndex}-to-${index}`,\n            isCommon: false,\n            prevIndex,\n            position: currentPositions[index],\n            prevPosition: prevPositions[prevIndex],\n          })\n        } else {\n          // This is a new letter - slide in from top\n          newLetterStates.push({\n            char,\n            index,\n            id: `${currentWord}-${char}-occ${currentOccurrence}-new-${index}`,\n            isCommon: false,\n            position: currentPositions[index],\n          })\n        }\n      }\n    })\n\n    setLetterStates(newLetterStates)\n  }, [currentWord, stableWords, calculatePositions])\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCurrentWord((prev) => {\n        const nextWord = prev + 1\n        // Check if we've completed one full cycle\n        if (nextWord >= stableWords.length) {\n          setShouldFadeOut(true)\n          return prev // Stay on last word\n        }\n        return nextWord\n      })\n    }, interval)\n    return () => clearInterval(timer)\n  }, [stableWords.length, interval])\n\n  return (\n    <AnimatePresence mode=\"popLayout\">\n      <motion.div\n        animate={{ opacity: shouldFadeOut ? 0 : 1 }}\n        className=\"absolute inset-0 flex items-center justify-start gap-2 bg-secondary px-16 font-black font-inter text-6xl\"\n        initial={{ opacity: 1 }}\n        transition={{ duration: 1, ease: \"easeOut\" }}\n      >\n        {/* Hidden span for measuring letter widths */}\n        <span\n          aria-hidden=\"true\"\n          className=\"invisible absolute font-black text-5xl uppercase\"\n          ref={measureRef}\n        />\n\n        <motion.div className=\"relative flex items-center justify-center gap-4\">\n          <span>{baseText}</span>â€¢\n          <div className={cn(\"relative h-[1.2em] text-primary\", textClassName)}>\n            {letterStates.map((letter) =>\n              letter.isCommon ? (\n                // Same position - stay static but fade out on exit\n                <motion.span\n                  animate={{ opacity: 1 }}\n                  className=\"-translate-y-1/2 absolute top-1/2 uppercase\"\n                  exit={{ opacity: 0 }}\n                  initial={{ opacity: 1 }}\n                  key={letter.id}\n                  style={{ left: letter.position }}\n                  transition={{ duration: 0.3 }}\n                >\n                  {letter.char}\n                </motion.span>\n              ) : (\n                <motion.span\n                  animate={{\n                    left: letter.position,\n                    opacity: 1,\n                  }}\n                  className=\"-translate-y-1/2 absolute top-1/2 uppercase\"\n                  exit={{\n                    opacity: 0,\n                  }}\n                  initial={\n                    letter.prevPosition !== undefined\n                      ? {\n                          // Different position - start from previous position\n                          left: letter.prevPosition,\n                          opacity: 1,\n                        }\n                      : {\n                          // New letter - slide in from top\n                          left: letter.position,\n                          opacity: 0,\n                        }\n                  }\n                  key={letter.id}\n                  transition={{\n                    duration: 0.5,\n                    ease: [0.4, 0.0, 0.2, 1],\n                  }}\n                >\n                  {letter.char}\n                </motion.span>\n              )\n            )}\n          </div>\n        </motion.div>\n      </motion.div>\n    </AnimatePresence>\n  )\n}\n",
      "type": "registry:component"
    }
  ],
  "meta": {
    "category": "unreal-page-entrances",
    "tags": ["text", "animation", "shuffle", "entrance"],
    "installCommand": "npx shadcn@latest add https://ui.totheprod.com/r/ttp-word-shuffler.json"
  }
}
